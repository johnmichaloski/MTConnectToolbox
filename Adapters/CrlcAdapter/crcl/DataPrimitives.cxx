// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataPrimitives.hxx"

// AngleUnitEnumType
// 

AngleUnitEnumType::
AngleUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v])
{
}

AngleUnitEnumType::
AngleUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const AngleUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

AngleUnitEnumType& AngleUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v]);

  return *this;
}


// DataThingType
// 

const DataThingType::Name_optional& DataThingType::
Name () const
{
  return this->Name_;
}

DataThingType::Name_optional& DataThingType::
Name ()
{
  return this->Name_;
}

void DataThingType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DataThingType::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void DataThingType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// ForceUnitEnumType
// 

ForceUnitEnumType::
ForceUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v])
{
}

ForceUnitEnumType::
ForceUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ForceUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

ForceUnitEnumType& ForceUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v]);

  return *this;
}


// FractionType
// 


// LengthUnitEnumType
// 

LengthUnitEnumType::
LengthUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v])
{
}

LengthUnitEnumType::
LengthUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const LengthUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

LengthUnitEnumType& LengthUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v]);

  return *this;
}


// PointType
// 

const PointType::X_type& PointType::
X () const
{
  return this->X_.get ();
}

PointType::X_type& PointType::
X ()
{
  return this->X_.get ();
}

void PointType::
X (const X_type& x)
{
  this->X_.set (x);
}

const PointType::Y_type& PointType::
Y () const
{
  return this->Y_.get ();
}

PointType::Y_type& PointType::
Y ()
{
  return this->Y_.get ();
}

void PointType::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const PointType::Z_type& PointType::
Z () const
{
  return this->Z_.get ();
}

PointType::Z_type& PointType::
Z ()
{
  return this->Z_.get ();
}

void PointType::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// PoseType
// 

const PoseType::Point_type& PoseType::
Point () const
{
  return this->Point_.get ();
}

PoseType::Point_type& PoseType::
Point ()
{
  return this->Point_.get ();
}

void PoseType::
Point (const Point_type& x)
{
  this->Point_.set (x);
}

void PoseType::
Point (::std::auto_ptr< Point_type > x)
{
  this->Point_.set (x);
}

const PoseType::XAxis_type& PoseType::
XAxis () const
{
  return this->XAxis_.get ();
}

PoseType::XAxis_type& PoseType::
XAxis ()
{
  return this->XAxis_.get ();
}

void PoseType::
XAxis (const XAxis_type& x)
{
  this->XAxis_.set (x);
}

void PoseType::
XAxis (::std::auto_ptr< XAxis_type > x)
{
  this->XAxis_.set (x);
}

const PoseType::ZAxis_type& PoseType::
ZAxis () const
{
  return this->ZAxis_.get ();
}

PoseType::ZAxis_type& PoseType::
ZAxis ()
{
  return this->ZAxis_.get ();
}

void PoseType::
ZAxis (const ZAxis_type& x)
{
  this->ZAxis_.set (x);
}

void PoseType::
ZAxis (::std::auto_ptr< ZAxis_type > x)
{
  this->ZAxis_.set (x);
}


// TorqueUnitEnumType
// 

TorqueUnitEnumType::
TorqueUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v])
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const TorqueUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

TorqueUnitEnumType& TorqueUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v]);

  return *this;
}


// VectorType
// 

const VectorType::I_type& VectorType::
I () const
{
  return this->I_.get ();
}

VectorType::I_type& VectorType::
I ()
{
  return this->I_.get ();
}

void VectorType::
I (const I_type& x)
{
  this->I_.set (x);
}

const VectorType::J_type& VectorType::
J () const
{
  return this->J_.get ();
}

VectorType::J_type& VectorType::
J ()
{
  return this->J_.get ();
}

void VectorType::
J (const J_type& x)
{
  this->J_.set (x);
}

const VectorType::K_type& VectorType::
K () const
{
  return this->K_.get ();
}

VectorType::K_type& VectorType::
K ()
{
  return this->K_.get ();
}

void VectorType::
K (const K_type& x)
{
  this->K_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// AngleUnitEnumType
//

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType* AngleUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AngleUnitEnumType (*this, f, c);
}

AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AngleUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_AngleUnitEnumType_indexes_,
                    _xsd_AngleUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_AngleUnitEnumType_indexes_ + 2 || _xsd_AngleUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const AngleUnitEnumType::
_xsd_AngleUnitEnumType_literals_[2] =
{
  "degree",
  "radian"
};

const AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_indexes_[2] =
{
  ::AngleUnitEnumType::degree,
  ::AngleUnitEnumType::radian
};

// DataThingType
//

DataThingType::
DataThingType ()
: ::xml_schema::type (),
  Name_ (this)
{
}

DataThingType::
DataThingType (const DataThingType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

DataThingType::
DataThingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DataThingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!this->Name_)
      {
        this->Name_.set (r);
        continue;
      }
    }

    break;
  }
}

DataThingType* DataThingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataThingType (*this, f, c);
}

DataThingType& DataThingType::
operator= (const DataThingType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

DataThingType::
~DataThingType ()
{
}

// ForceUnitEnumType
//

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType* ForceUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceUnitEnumType (*this, f, c);
}

ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceUnitEnumType_indexes_,
                    _xsd_ForceUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ForceUnitEnumType_indexes_ + 3 || _xsd_ForceUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceUnitEnumType::
_xsd_ForceUnitEnumType_literals_[3] =
{
  "newton",
  "pound",
  "ounce"
};

const ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_indexes_[3] =
{
  ::ForceUnitEnumType::newton,
  ::ForceUnitEnumType::ounce,
  ::ForceUnitEnumType::pound
};

// FractionType
//

FractionType::
FractionType (const ::xml_schema::decimal& _xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
{
}

FractionType::
FractionType (const FractionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
{
}

FractionType::
FractionType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
{
}

FractionType* FractionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FractionType (*this, f, c);
}

FractionType::
~FractionType ()
{
}

// LengthUnitEnumType
//

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType* LengthUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LengthUnitEnumType (*this, f, c);
}

LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LengthUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_LengthUnitEnumType_indexes_,
                    _xsd_LengthUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_LengthUnitEnumType_indexes_ + 3 || _xsd_LengthUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const LengthUnitEnumType::
_xsd_LengthUnitEnumType_literals_[3] =
{
  "meter",
  "millimeter",
  "inch"
};

const LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_indexes_[3] =
{
  ::LengthUnitEnumType::inch,
  ::LengthUnitEnumType::meter,
  ::LengthUnitEnumType::millimeter
};

// PointType
//

PointType::
PointType (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
: ::DataThingType (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

PointType::
PointType (const PointType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

PointType::
PointType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      if (!X_.present ())
      {
        this->X_.set (X_traits::create (i, f, this));
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      if (!Y_.present ())
      {
        this->Y_.set (Y_traits::create (i, f, this));
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      if (!Z_.present ())
      {
        this->Z_.set (Z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Z",
      "");
  }
}

PointType* PointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PointType (*this, f, c);
}

PointType& PointType::
operator= (const PointType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

PointType::
~PointType ()
{
}

// PoseType
//

PoseType::
PoseType (const Point_type& Point,
          const XAxis_type& XAxis,
          const ZAxis_type& ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (::std::auto_ptr< Point_type > Point,
          ::std::auto_ptr< XAxis_type > XAxis,
          ::std::auto_ptr< ZAxis_type > ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (const PoseType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Point_ (x.Point_, f, this),
  XAxis_ (x.XAxis_, f, this),
  ZAxis_ (x.ZAxis_, f, this)
{
}

PoseType::
PoseType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Point_ (this),
  XAxis_ (this),
  ZAxis_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Point
    //
    if (n.name () == "Point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Point_type > r (
        Point_traits::create (i, f, this));

      if (!Point_.present ())
      {
        this->Point_.set (r);
        continue;
      }
    }

    // XAxis
    //
    if (n.name () == "XAxis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< XAxis_type > r (
        XAxis_traits::create (i, f, this));

      if (!XAxis_.present ())
      {
        this->XAxis_.set (r);
        continue;
      }
    }

    // ZAxis
    //
    if (n.name () == "ZAxis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ZAxis_type > r (
        ZAxis_traits::create (i, f, this));

      if (!ZAxis_.present ())
      {
        this->ZAxis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Point_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Point",
      "");
  }

  if (!XAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "XAxis",
      "");
  }

  if (!ZAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ZAxis",
      "");
  }
}

PoseType* PoseType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseType (*this, f, c);
}

PoseType& PoseType::
operator= (const PoseType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Point_ = x.Point_;
    this->XAxis_ = x.XAxis_;
    this->ZAxis_ = x.ZAxis_;
  }

  return *this;
}

PoseType::
~PoseType ()
{
}

// TorqueUnitEnumType
//

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType* TorqueUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TorqueUnitEnumType (*this, f, c);
}

TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TorqueUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_TorqueUnitEnumType_indexes_,
                    _xsd_TorqueUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_TorqueUnitEnumType_indexes_ + 2 || _xsd_TorqueUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_literals_[2] =
{
  "newtonMeter",
  "footPound"
};

const TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_indexes_[2] =
{
  ::TorqueUnitEnumType::footPound,
  ::TorqueUnitEnumType::newtonMeter
};

// VectorType
//

VectorType::
VectorType (const I_type& I,
            const J_type& J,
            const K_type& K)
: ::DataThingType (),
  I_ (I, this),
  J_ (J, this),
  K_ (K, this)
{
}

VectorType::
VectorType (const VectorType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

VectorType::
VectorType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  I_ (this),
  J_ (this),
  K_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VectorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // I
    //
    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      if (!I_.present ())
      {
        this->I_.set (I_traits::create (i, f, this));
        continue;
      }
    }

    // J
    //
    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      if (!J_.present ())
      {
        this->J_.set (J_traits::create (i, f, this));
        continue;
      }
    }

    // K
    //
    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      if (!K_.present ())
      {
        this->K_.set (K_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!I_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I",
      "");
  }

  if (!J_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "J",
      "");
  }

  if (!K_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "K",
      "");
  }
}

VectorType* VectorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VectorType (*this, f, c);
}

VectorType& VectorType::
operator= (const VectorType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->I_ = x.I_;
    this->J_ = x.J_;
    this->K_ = x.K_;
  }

  return *this;
}

VectorType::
~VectorType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const AngleUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AngleUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AngleUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DataThingType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Name",
        e));

    s << *i.Name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ForceUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FractionType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FractionType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FractionType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const LengthUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const LengthUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const LengthUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const PointType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // X
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X",
        e));

    s << ::xml_schema::as_decimal(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Y",
        e));

    s << ::xml_schema::as_decimal(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Z",
        e));

    s << ::xml_schema::as_decimal(i.Z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PoseType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Point
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Point",
        e));

    s << i.Point ();
  }

  // XAxis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "XAxis",
        e));

    s << i.XAxis ();
  }

  // ZAxis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ZAxis",
        e));

    s << i.ZAxis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TorqueUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const TorqueUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const TorqueUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const VectorType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // I
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "I",
        e));

    s << ::xml_schema::as_decimal(i.I ());
  }

  // J
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "J",
        e));

    s << ::xml_schema::as_decimal(i.J ());
  }

  // K
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "K",
        e));

    s << ::xml_schema::as_decimal(i.K ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

